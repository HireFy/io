### 关于python线程的想法

在python中，多线程由于GIL的原因，不能够是真正的多线程，我就尽我知道的，胡说一些。
因为多线程它是由一个进程引导的，而python中一个进程要运行，需要注册GIL，它才能够
在CPU上运行。那这个进程拥有的线程，要运行，也需要一个GIL，才能运行。一个进程只能
有一个！所以每次线程都会先争夺GIL的锁，拿到GIL锁的才能够运行。这就是Python多线程
性能不怎么样的原因。相反，多进程就有多个GIL，这样运行效率就会比多线程要好得多。

参考链接:http://www.imooc.com/article/16198

__我自己写的练习__


案例1
```python

import threading
import time


class Mythread(threading.Thread):
    def __init__(self, name):
        threading.Thread.__init__(self)
        self.name = name

    def run(self):
        #data = set(list(range(100)))
        a = data.pop()
        print('thread', self.name, 'get a data :', a, 'at ', time.strftime('%S'))


lock = threading.Lock()
threads = []
data = set(list(range(100)))
for i in range(20):
    threadTest = Mythread(str(i))
    threads.append(threadTest)

for i in threads:
    i.start()

print(threading.current_thread().name, 'is done!')

```

案例2
```python
import time
import threading

def change():
    data = threading.current_thread().name
    print(threading.current_thread().name, 'is running!')
    print(threading.current_thread().name, ': data is', data)


def threadJob():
    global data
    while True:
        lock.acquire()
        change()
        lock.release()
        time.sleep(0.5)


# 定义一个变量
lock = threading.Lock()
data = 'M'
threadA = threading.Thread(target=threadJob, name='A')
threadB = threading.Thread(target=threadJob, name='B')
threadA.start()
threadB.start()
#threadA.join(0.1)
#threadB.join(0.1)

threadJob()

```

